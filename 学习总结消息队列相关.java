/**
 * @Author shizq18
 * @Date 2023/10/27
 * @Description
 */
public class 学习总结消息队列相关 {
    /**
     * mq和kafka的对比：
     * 为了实现发布订阅功能，从而使用的消息复制，会降低性能并耗费更多资源
     * 多个消费者无法严格保证消息顺序
     * 大量的订单集中在一个队列，吞吐量受到了限制
     *
     * =========================topic：如何保证顺序性====================
     * 对于每一个topic， Kafka集群都会维持一个分区日志，如下所示：
     * 每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log
     * 文件。分区中的每一个记录都会分配一个id号来表示顺序，我们称之为offset，
     * offset用来唯一的标识分区中每一条记录。
     * Kafka 集群保留所有发布的记录—无论他们是否已被消费—并通过一个可配置的参数
     * ——保留期限来控制. 举个例子， 如果保留策略设置为2天，一条记录发布后两天内，
     * 可以随时被消费，两天过后这条记录会被抛弃并释放磁盘空间。Kafka的性能和数据
     * 大小无关，所以长时间存储数据没有什么问题.
     * Kafka 只保证分区内的记录是有序的，而不保证主题中不同分区的顺序。
     * Kafka 设计的更好。topic中的partition是一个并行的概念。 Kafka能够为一个
     * 消费者池提供顺序保证和负载平衡，是通过将topic中的partition分配给消费者组中
     * 的消费者来实现的， 以便每个分区由消费组中的一个消费者消耗。通过这样，我们能够
     * 确保消费者是该分区的唯一读者，并按顺序消费数据。 众多分区保证了多个消费者实例
     * 间的负载均衡。但请注意，消费者组中的消费者实例个数不能超过分区的数量。
     *
     * ======================分布式：如何保证可用性===========================
     * 日志的分区partition （分布）在Kafka集群的服务器上。每个服务器在处理数据和请求时，
     * 共享这些分区。每一个分区都会在已配置的服务器上进行备份，确保容错性.
     * 每个分区都有一台 server 作为 “leader”，零台或者多台server作为 follwers 。
     * leader server 处理一切对 partition （分区）的读写请求，而follwers只需被动的
     * 同步leader上的数据。当leader宕机了，followers 中的一台服务器会自动成为新的
     * leader。每台 server 都会成为某些分区的 leader 和某些分区的 follower，
     * 因此集群的负载是平衡的。
     */
}
